import { AIMessage } from "@langchain/core/messages";
import { Command } from "@langchain/langgraph";
import { ChatOpenAI } from "@langchain/openai";
import { ExtendedState } from "../../../states/states";
import { AgentType } from "../types/agents";
import { logEvent } from "../agents/supervisor-agent";
import { MutationInfo } from "./index";
import { loadTemplatePrompt } from "../prompts/configurable-prompt-resolver";
import { safeCreateMemoryMap } from "../utils/memory-helpers";

/**
 * Generates a GraphQL mutation based on intent and type information
 */
export const mutationGenerationNode = async (
  state: ExtendedState,
  config: any
) => {
  logEvent("info", AgentType.TOOL, "mutation_generation_start");

  try {
    // Get mutation context from state
    const mutationContext = state.memory?.get("mutationContext");
    if (!mutationContext) {
      throw new Error("No mutation context found in state");
    }

    // Get current task
    const taskState = state.memory?.get("taskState");
    const currentTask = taskState?.tasks?.find(
      (task: any) => task.status === "in_progress"
    );
    if (!currentTask) {
      throw new Error("No current task found");
    }

    // Get intent match and type details
    const intentMatch = mutationContext.intentMatch;
    const typeDetails = mutationContext.typeDetails;
    if (!intentMatch || !typeDetails) {
      throw new Error("Missing intent match or type details");
    }

    // Get available mutations
    const availableMutations = mutationContext.availableMutations;
    if (!availableMutations?.length) {
      throw new Error("No available mutations found");
    }

    // Create LLM for mutation generation
    const model = new ChatOpenAI({
      model: "gpt-4",
      temperature: 0,
    });

    // Load the mutation generation prompt using configurable template system
    let prompt = "";
    try {
      // Store mutation-specific data in state memory for template access
      state.memory?.set("intentMatch", intentMatch);
      state.memory?.set("availableMutations", availableMutations);
      state.memory?.set("typeDetails", typeDetails);
      // DON'T overwrite userRequest with task description - preserve original user request

      const promptResult = await loadTemplatePrompt(
        "template_mutation_generation",
        state,
        config,
        model,
        false
      );

      prompt = promptResult.populatedPrompt?.value || "";
      console.log(
        "ðŸ”§ MUTATION GENERATION - Successfully loaded configurable template prompt"
      );
    } catch (error) {
      console.warn(
        "Failed to load mutation generation template prompt:",
        error
      );
      // Fallback to default prompt
      prompt = `You are a GraphQL mutation generation expert. Your task is to generate a mutation based on the user's intent and available type information.

User Intent:
${intentMatch.reason}

Available Mutations:
${availableMutations
  .map(
    (m: MutationInfo) => `
- ${m.name}
  Description: ${m.description}
  Document: ${m.document}
`
  )
  .join("\n")}

Type Details:
${JSON.stringify(typeDetails, null, 2)}

Instructions:
1. Select the most appropriate mutation based on the user's intent
2. Generate the mutation variables based on the type information
3. Ensure all required fields are included
4. Follow GraphQL best practices
5. Return the result in this exact format:
{
  "mutation": {
    "name": "mutation name",
    "document": "mutation document",
    "variables": {
      "variable1": "value1",
      "variable2": "value2"
    }
  },
  "explanation": "Brief explanation of the mutation"
}

Remember:
- Use the exact mutation name from the available mutations
- Include all required variables
- Follow the type structure exactly
- Validate against the type information`;
    }

    // Generate mutation using LLM
    const response = await model.invoke([new AIMessage(prompt)]);

    // Parse the response
    let generatedMutation;
    try {
      const content =
        typeof response.content === "string"
          ? response.content
          : JSON.stringify(response.content);
      generatedMutation = JSON.parse(content);
    } catch (error) {
      throw new Error(`Failed to parse LLM response: ${error.message}`);
    }

    // Validate generated mutation
    if (
      !generatedMutation.mutation?.name ||
      !generatedMutation.mutation?.document
    ) {
      throw new Error("Invalid mutation generated by LLM");
    }

    // Update mutation context with generated mutation
    const updatedMutationContext = {
      ...mutationContext,
      mutation: generatedMutation.mutation,
      explanation: generatedMutation.explanation,
    };

    // Update state
    const updatedState = {
      ...state,
      memory: safeCreateMemoryMap(state.memory).set(
        "mutationContext",
        updatedMutationContext
      ),
    };

    // Log success
    logEvent("info", AgentType.TOOL, "mutation_generation_success", {
      mutationName: generatedMutation.mutation.name,
      explanation: generatedMutation.explanation,
    });

    // Return command to continue to mutation execution
    return new Command({
      goto: "MUTATION_EXECUTION",
      update: {
        messages: [
          ...state.messages,
          new AIMessage({
            content: `Generated mutation: ${generatedMutation.explanation}`,
          }),
        ],
        memory: updatedState.memory,
      },
    });
  } catch (error) {
    // Log error
    logEvent("error", AgentType.TOOL, "mutation_generation_error", {
      error: error.message,
    });

    // Update task with error
    const taskState = state.memory?.get("taskState");
    const currentTask = taskState?.tasks?.find(
      (task: any) => task.status === "in_progress"
    );
    if (currentTask) {
      const updatedTaskState = {
        ...taskState,
        tasks: taskState.tasks.map((task: any) =>
          task.id === currentTask.id
            ? { ...task, status: "failed", error: error.message }
            : task
        ),
      };

      return new Command({
        goto: AgentType.SUPERVISOR,
        update: {
          messages: [
            ...state.messages,
            new AIMessage({
              content: `Failed to generate mutation: ${error.message}`,
            }),
          ],
          memory: safeCreateMemoryMap(state.memory).set(
            "taskState",
            updatedTaskState
          ),
        },
      });
    }

    // If no current task, just return error
    return new Command({
      goto: AgentType.SUPERVISOR,
      update: {
        messages: [
          ...state.messages,
          new AIMessage({
            content: `Failed to generate mutation: ${error.message}`,
          }),
        ],
      },
    });
  }
};
